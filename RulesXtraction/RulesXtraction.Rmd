---
title: "Extracción de reglas"
author: "Laura del Pino Díaz"
date: "23/1/2017"
header-includes: \usepackage[spanish]{babel}
output: pdf_document
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width=60)
knitr::opts_chunk$set(comment = "", warning = FALSE, message = FALSE, echo = TRUE, tidy = TRUE, size="small")
```
\newpage
#Introducción

La extracción de reglas de asociación es una técnica de la minería de datos que nos permite extraer conocimiento de las bases de datos. En este trabajo trata de extraer conocimiento de la base de datos _mushrooms_. 

La base de datos _mushrooms_ contiene los atributos que describen las setas y que permitirían clasificar las setas observadas en venenosas y comestibles. Los atributos se listan a continuación:


* cap-shape: bell=b,conical=c,convex=x,flat=f, knobbed=k,sunken=s
* cap-surface: fibrous=f,grooves=g,scaly=y,smooth=s
* cap-color: brown=n,buff=b,cinnamon=c,gray=g,green=r,pink=p,purple=u,red=e,white=w,yellow=y
* bruises: bruises=t,no=f
* odor: almond=a,anise=l,creosote=c,fishy=y,foul=f,musty=m,none=n,pungent=p,spicy=s
* gill-attachment: attached=a,descending=d,free=f,notched=n
* gill-spacing: close=c,crowded=w,distant=d
* gill-size: broad=b,narrow=n
* gill-color: black=k,brown=n,buff=b,chocolate=h,gray=g, green=r,orange=o,
  pink=p,purple=u,red=e,white=w,yellow=y
* stalk-shape: enlarging=e,tapering=t
* stalk-root: bulbous=b,club=c,cup=u,equal=e,rhizomorphs=z,rooted=r,missing=?
* stalk-surface-above-ring: fibrous=f,scaly=y,silky=k,smooth=s
* stalk-surface-below-ring: fibrous=f,scaly=y,silky=k,smooth=s
* stalk-color-above-ring: brown=n,buff=b,cinnamon=c,gray=g,orange=o,pink=p,red=e,white=w,yellow=y
* stalk-color-below-ring: brown=n,buff=b,cinnamon=c,gray=g,orange=o,pink=p,red=e,white=w,yellow=y
* veil-type: partial=p,universal=u
* veil-color: brown=n,orange=o,white=w,yellow=y
* ring-number: none=n,one=o,two=t
* ring-type: cobwebby=c,evanescent=e,flaring=f,large=l,none=n,pendant=p,sheathing=s,zone=z
* spore-print-color: black=k,brown=n,buff=b,chocolate=h,green=r,orange=o,purple=u,white=w,yellow=y
* population: abundant=a,clustered=c,numerous=n,scattered=s,several=v,solitary=y
* habitat: grasses=g,leaves=l,meadows=m,paths=p,urban=u,waste=w,woods=d


```{r}
datos = read.csv("mushrooms.csv")
```
\newpage
#Preparación de los datos

Para realizar la extracción de reglas tenemos que preparar los datos para que estén en un formato que nos facilite el trabajo. Este formato es un formato binario donde los valores sean 0 y 1 que nos permita extraer el los casos en los que aparece el atributo y en los que no, para metricas como la _confianza confirmada_ es necesario conocer los casos en donde se da un valor y su contrario. 

Esta transformación la conseguimos con el siguiente conjunto de funciones:

```{r}
transformDataToBinary <- function(lvl,data){
  result = sapply(data,function(x){ifelse(x==lvl,1,0)})
  return(result)
}

selectData <-function(column){
   if(is.factor(column) && length(levels(column))>2){
     lvls = levels(column)
     m = matrix(nrow = 8124, ncol = 0)
     m = data.frame(m)
     for(lvl in lvls){
      d = transformDataToBinary(lvl,column)
      d = as.factor(d)
      m = cbind(m,d)
     }
     colnames(m) <- lvls
     return(m)
   }
  else if(!is.factor(column)){
    return(selectData(as.factor(column)))
  }
  else{
    return(column)
  }
}

expandedDataFrame =cbind(datos[,-19],selectData(datos[,"ring.number"])) 
```

En estos momentos en _expandedDataFrame_ tenemos 25 variables, las 22 anteriores y las tres variables binarias creadas a partir de la variable _ring.number_. 

Por suerte todas las variables son categóricas, lo que nos facilita el preprocesamiento al no tener que dividir ningún dominio en intervalos.

Ahora que ya tenemos el dataframe en un estado que nos favorece nos queda que cambiar la interpretación que le damos, para que sea del tipo transacción. Para ello cargamos el paquete _arules_ que nos permitirá hacer dicha transformación y además cargaremos el paquete de visualización de reglas de asociación _arulesViz_ que será útil en pasos posteriores.

\newpage
```{r, message=FALSE,warning=FALSE}
require(arules)
require(arulesViz)

transactionData <- as(expandedDataFrame, "transactions")
summary(transactionData)
```


Del resumen anterior obtenermos que los elementos más repetidos son _veil.type=p_, que se da para todas las observaciones de la base de datos, seguido por _n=0_ que es una de las variables generadas a partir de _ring.number_ de carácter binaria, por lo que se estima que sea más normal que las otras dos variables tomen valores, en concreto la variable _o_ dado que la variable _t_ aparece como item frecuente con el valor 0. A parte de estas tres variables tenemos como item frecuentes _veil.color_ con el valor _w_ y _gill.attachment_ con el valor _f_ 

Además obtenemos la información sobre la longitud máxima de la transacción que en todos los casos es 25, el número de variables, esto es debido a que no falta ninguna variable. 

\newpage
#Visualización de las transacciones

En el caso de que las variables tomasen solamente los valores _si_ o _no_ podríamos y que el número de variables en cada transacción fuese distinto podría ser interesante realizar una visualización de las transacciones. Pero dado que este no es el caso solamente visualizaremos los conjuntos de items más frecuentes, como en la siguiente imagen, donde miramos aquellos items que tienen un valor de soporte mayor que 0.9. 

```{r, fig.width=3, fig.align='center'}
itemFrequencyPlot(transactionData, support = 0.9, cex.names=0.75)
```

De la imagen anterior podemos deducir que aquellas reglas con las variables _gill.attachment=f_, _veil.type=p_, _veil.color=w_, _n=0_, _o=1_ y _t=0_ serán reglas que no aportarán información puesto que se cumplirán en almenos el 90% de los casos recogidos en la base de datos. 

```{r}
itemFrequencyPlot(transactionData, support = 0.2, cex.names=0.6)
```

El gráfico anterior representa una población de aproximadamente 40 items que se convierten en frecuentes al determinar el umbral de soporte en 0.2 . 40 items representa una cantidad significativa de los valores que pueden tomar las variables de nuestra base de datos. Podemos dejar el soporte mínimo en 0.2, para tener un conjunto significativo de items con los que trabajar. 

#Itemset frecuentes

Para extraer los itemset frecuentes, utilizaremos el método _apriori_ que irá buscando para cada longitud de itemset aquellos itemsets que tengan un valor de soporte mayor que el que se ha determinado como mínimo, en nuestro caso 0.2. Tras ello lo ordenaremos por soporte y mostraremos una relación entre la longitud del itemset y la frecuencia absoluta de cada longitud. Siempre teniendo en cuenta que se nos van a devolver solamente los itemset de longitud menor o igual a 10. 

```{r, warning=FALSE}
aPrioriTransactionData = apriori(transactionData, parameter = list(support = 0.2, target="frequent"),control=list(verbose=F))
aPrioriTransactionData = sort(aPrioriTransactionData, by="support")
```


```{r}
barplot(table(size(aPrioriTransactionData)), xlab="itemsetsize", ylab="count")
```

En la gráfica anterior podemos ver como aumenta el número de superconjuntos con la longitud del itemset, manteniéndose estos nuevos conjuntos como frecuentes siguiendo la propiedad antimonótona de los itemset que afirma que cualquier subconjunto de un itemset tiene mayor o igual soporte que el itemset del que proviene.

Vamos a insperccionar el soporte de los itemsets de longitud 1 que hemos obtenido.

```{r}
inspect(head(aPrioriTransactionData[size(aPrioriTransactionData)==1],10))
```


Los primeros 4 elementos tienen un soporte realmente alto, por lo que cualquier regla que se produzca con ellos puede no dar información relevante. 
\newpage

#Comparación del número de itemset frecuentes, conjuntos maximales y conjuntos cerrados
Para conocer mejor los itemset obtenidos por el método _a priori_ realizaremos una comparativa de los conjuntos maximales, cerrados y frecuentes.

```{r}
icloAPrioriTransactionData<-aPrioriTransactionData[is.closed(aPrioriTransactionData)]
imaxAPrioriTransactionData<-aPrioriTransactionData[is.maximal(aPrioriTransactionData)]
barplot( c(frequent=length(aPrioriTransactionData), closed=length(aPrioriTransactionData), maximal=length(aPrioriTransactionData)), ylab="count", xlab="itemsets")
```

Al ver el número de itemset cerrados y maximales tan igual, podemos decir que los conjuntos son iguales, por lo que podemos presindir del conjunto de los maximales, dado que el conjunto de los itemset cerrados nos permite tener la lista de los más frecuentes y a la vez tener la información del soporte. 

\newpage
#Obtención de reglas

Para la obtención de reglas usamos apriori y le indicamos que el soporte mínimo es de 0.2 como ya habíamos establecido antes. Además le indicamos que la confianza mínima de la regla es de 0.75, este valor lo establecemos así para tener mayor conjunto de reglas que estudiar aparte de las que van a tener un valor alto por contener aquellos items que tienen soporte muy próximo a 1. 

```{r}
rules <-apriori(transactionData, parameter = list(support = 0.2, confidence = 0.75, minlen= 2),control=list(verbose=F))

summary(rules)
```