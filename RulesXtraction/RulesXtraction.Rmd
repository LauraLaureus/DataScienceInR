---
title: "Extracción de reglas"
author: "Laura del Pino Díaz"
date: "23/1/2017"
header-includes: \usepackage[spanish]{babel}
output: pdf_document
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introducción

La extracción de reglas de asociación es una técnica de la minería de datos que nos permite extraer conocimiento de las bases de datos. En este trabajo trata de extraer conocimiento de la base de datos _lymphography_. 

La base de datos _lymphography_ contiene los atributos más descriptivos de las linfografías médicas, a saber:

* Lymphatics, nominal cuyos valores son {normal,arched,deformed,displaced}
* Block_of_affere de tipo nominal que toma los valores {no,yes}
* Bl_of_lymph_c de tipo nominal que toma los valores {no,yes}
* Bl_of_lymph_s de tipo nominal que toma los valores {no,yes}
* By_pas de tipo nominal que toma los valores {no,yes}
* Extravasates de tipo nominal que toma los valores {no,yes}
* Regeneration_of de tipo nominal que toma los valores {no,yes}
* Early_uptake_in de tipo nominal que toma los valores {no,yes}
* Lym_nodes_dimi de tipo numérico discreto que toma los valores [0,3]
* Lym_nodes_enlar de tipo numérico que toma los valores [1,4]
* Change_in_lym de tipo nominal que toma los valores {bean,oval,round}
* Defect_in_node de tipo nominal que toma los valores {no,lacunar,lac_margin,lac_central}
* Changes_in_node de tipo nominal que toma los valores {no,lacunar,lac_margin,lac_central}
* Changes_in_stru de tipo nominal que toma los valores {no,grainy,drop_lik,coarse,diluted,reticular,stripped,faint}
* Special_form de tipo nominal que toma los siguientes valores {no,chalices,vesicles}
* Dislocation_of de tipo nominal que toma los valores {no,yes}
* Exclusion_of_no de tipo nominal que toma los valores {no,yes}
* No_of_nodes_in de tipo numérico discreto que toma los valores [1,8]
* Class de tipo nominal que toma los valores {normal,metastases,malig_lymph,fibrosis}

La base de datos la he tomado de la página web de KEEL por lo que habrá que tener en cuenta el apartado descriptivo que aparece en la parte superior del fichero.

```{r}
#datos <- read.csv("lymphography.dat", comment.char = "@")
#colnames(datos) <- c("Lymphatics", "Block_of_affere", "Bl_of_lymph_c","Bl_of_lymph_s","By_pas", "Extravasates","Regeneration_of","Early_uptake_in","Lym_nodes_dimi","Lym_nodes_enlar","Change_in_lym","Defect_in_node","Changes_in_node","Changes_in_stru", "Special_form","Dislocation_of","Exclusion_of_no","No_of_nodes_in","Class")

datos = read.csv("mushrooms.csv")
```
\newpage
#Preparación de los datos

Para realizar la extracción de reglas tenemos que preparar los datos para que estén en un formato que nos facilite el trabajo. Este formato es un formato binario donde los valores sean 0 y 1 que nos permita extraer el los casos en los que aparece el atributo y en los que no, para metricas como la _confianza confirmada_ es necesario conocer los casos en donde se da un valor y su contrario. 

Esta transformación la conseguimos con el siguiente conjunto de funciones:

```{r}
transformDataToBinary <- function(lvl,data){
  result = sapply(data,function(x){ifelse(x==lvl,1,0)})
  return(result)
}

selectData <-function(column){
   if(is.factor(column) && length(levels(column))>2){
     lvls = levels(column)
     m = matrix(nrow = 147, ncol = 0)
     m = data.frame(m)
     for(lvl in lvls){
      d = transformDataToBinary(lvl,column)
      d = as.factor(d)
      m = cbind(m,d)
     }
     colnames(m) <- lvls
     return(m)
   }
  else if(!is.factor(column)){
    return(selectData(as.factor(column)))
  }
  else{
    return(column)
  }
}

expandDataFrame <- function(dataFrame){
  extendedData = selectData(datos[,1])
  for(i in 2:(dim(dataFrame)[2])){
    extendedData = cbind(extendedData,selectData(datos[,i]))
  }
  return(extendedData)
}

expandedDataFrame =cbind(datos[,-5],selectData(datos[,5])) 
```

En estos momentos en _expandedDataFrame_ tenemos 54 variables creadas a partir de los valores que toman las variables, esto es, si la variable es categorica y tenía tres posibles valores tenemos tres variables a partir de esta de forma que cada nueva variable toma valores de 0 o 1 donde 0 es si no tiene ese valor y 1 en caso de que si toma el valor.

Por suerte aquellas variables que no son categóricas son numéricas discretas con un conjunto reducido de valores de forma que se puede crear una variable por cada uno de los valores del dominio de la variable. 

Por desgracia la salida de la función _expandDataFrame_ no da nombres significativos a todas las variables por lo que es conveniente cambiarles el valor a aquellas que no tienen nombre representativo o que el nombre se repite produciendo confusión.

Por restricciones sobre el número de páginas la sección de código que modifica los nombres de las columnas no se muestra. Se recomienda abrir el fichero .Rmd para visualizarlo. 

```{r,echo=FALSE}
#str(expandedDataFrame) No todas las columnas tienen un nombre representativo

namesExpanedDataFrame = names(expandedDataFrame)
namesExpanedDataFrame[5] = "Block_of_affere"
namesExpanedDataFrame[6] = "Bl_of_lymph_c"
namesExpanedDataFrame[7] = "Bl_of_lymph_s"
namesExpanedDataFrame[8] = "By_pas"
namesExpanedDataFrame[9] = "Extravasates"
namesExpanedDataFrame[10] = "Regeneration_of"
namesExpanedDataFrame[11] = "Early_uptake_in"
namesExpanedDataFrame[12] = "Lym_nodes_dimi=1"
namesExpanedDataFrame[13] = "Lym_nodes_dimi=2"
namesExpanedDataFrame[14] = "Lym_nodes_dimi=3"
namesExpanedDataFrame[15] = "Lym_nodes_enlar=1"
namesExpanedDataFrame[16] = "Lym_nodes_enlar=2"
namesExpanedDataFrame[17] = "Lym_nodes_enlar=3"
namesExpanedDataFrame[18] = "Lym_nodes_enlar=4"
namesExpanedDataFrame[22] = "Defect_in_node=lac_central"
namesExpanedDataFrame[23] = "Defect_in_node=lac_margin"
namesExpanedDataFrame[24] = "Defect_in_node=lacunar"
namesExpanedDataFrame[25] = "Defect_in_node=no"
namesExpanedDataFrame[26] = "Changes_in_node=lac_central"
namesExpanedDataFrame[27] = "Changes_in_node=lac_margin"
namesExpanedDataFrame[28] = "Changes_in_node=lacunar"
namesExpanedDataFrame[29] = "Changes_in_node=no"
namesExpanedDataFrame[30] = "Changes_in_stru=coarsed"
namesExpanedDataFrame[31] = "Changes_in_stru=diluted"
namesExpanedDataFrame[32] = "Changes_in_stru=drop_like"
namesExpanedDataFrame[33] = "Changes_in_stru=faint"
namesExpanedDataFrame[34] = "Changes_in_stru=grainy"
namesExpanedDataFrame[35] = "Changes_in_stru=no"
namesExpanedDataFrame[36] = "Changes_in_stru=reticular"
namesExpanedDataFrame[37] = "Changes_in_stru=stripped"
namesExpanedDataFrame[41] = "Dislocation_of"
namesExpanedDataFrame[42] = "Exclusion_of_no"
namesExpanedDataFrame[43] = "No_of_nodes_in=1"
namesExpanedDataFrame[44] = "No_of_nodes_in=2"
namesExpanedDataFrame[45] = "No_of_nodes_in=3"
namesExpanedDataFrame[46] = "No_of_nodes_in=4"
namesExpanedDataFrame[47] = "No_of_nodes_in=5"
namesExpanedDataFrame[48] = "No_of_nodes_in=6"
namesExpanedDataFrame[49] = "No_of_nodes_in=7"
namesExpanedDataFrame[50] = "No_of_nodes_in=8"
namesExpanedDataFrame[54] = "Class=normal"
colnames(expandedDataFrame) <- namesExpanedDataFrame
```

Ahora que ya tenemos el dataframe en un estado que nos favorece nos queda que cambiar la interpretación que le damos, para que sea del tipo transacción. Para ello cargamos el paquete _arules_ que nos permitirá hacer dicha transformación y además cargaremos el paquete de visualización de reglas de asociación _arulesViz_ que será útil en pasos posteriores.

```{r}
require(arules)
require(arulesViz)

transactionData <- as(expandedDataFrame, "transactions")
summary(transactionData)
```

Del resumen anterior obtenermos que los elementos más repetidos son _normal=0_, _Changes in stru=no=0_, _Changes in stru=reticular=0_, _Changes in no nodes=8=0_, _Class=normal=0_ lo que quiere decir que:

* En la mayoría de las transacciones hay un tipo de linfático distinto del normal.
* En la mayoría de las transacciones hay algún tipo de cambio en la estructura que no es de tipo reticular, convirtiendo este tipo en el más raro con solo dos casos.
* El cambio en el número de nodos es en la mayoría de los casos distinto de 8.
* Es raro el caso en el que el linfoma sea normal.

Además tenemos la información sobre la longitud máxima de la transacción que en este caso coincide con el número de variables. 

#Visualización de las transacciones

Podemos visualizar las transacciones para ver su comportamiento:

```{r,fig.align="center"}
image(transactionData)
```

De la imagen anterior podemos deducir que las transacciones,

Si nos interesa visualizar los items con mayor frecuencia tenemos que reducir los items por el soporte a aquellos que tienen dicho valor a .9 de otra forma la figura sería imposible visualizar algo.

```{r}
itemFrequencyPlot(transactionData, support = 0.9, cex.names=0.8)
```

El hecho de que la mayoría de los items mostrados tengan el valor, significa que la información interesante está en las otras variables que toman distintos valores. 

Aún sabiendo que la imagen no mostrará correctamente los nombres de las variables vamos a visualizar los items que se convertirían en frecuentes si se baja el valor de soporte.

```{r}
itemFrequencyPlot(transactionData, support = 0.2, cex.names=0.8)
```

El gráfico anterior representa una población de aproximadamente 80 items que se convierten en frecuentes al determinar el umbral en 0.2. 80 items representa más de la mitad de las posibilidades que obtenemos de multiplicar las 54 variables por los 2 posibles valores que pueden tomar. 

#Itemset frecuentes

```{r}
aPrioriTransactionData = apriori(transactionData, parameter = list(support = 0.1, target="frequent"))
aPrioriTransactionData = sort(aPrioriTransactionData, by="support")
```


```{r}
size(aPrioriTransactionData)
barplot(table(size(aPrioriTransactionData)), xlab="itemsetsize", ylab="count")
inspect(aPrioriTransactionData[size(aPrioriTransactionData)==1])
```

##Conjuntos maximales

```{r}
imaxAPrioriTransactionData<-aPrioriTransactionData[is.maximal(aPrioriTransactionData)]
inspect(head(sort(imaxAPrioriTransactionData, by="support")))
```

##Conjuntos cerrados

```{r}
icloAPrioriTransactionData<-aPrioriTransactionData[is.closed(aPrioriTransactionData)]
inspect(head(sort(icloAPrioriTransactionData, by="support")))
```

##Comparación del número de itemset frecuentes, conjuntos maximales y conjuntos cerrados

```{r}
barplot( c(frequent=length(aPrioriTransactionData), closed=length(aPrioriTransactionData), maximal=length(aPrioriTransactionData)), ylab="count", xlab="itemsets")
```

```{r}
rules <-apriori(transactionData, parameter = list(support = 0.1, confidence = 0.8, minlen= 2))

summary(rules)
```